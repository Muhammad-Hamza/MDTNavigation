package com.karwa.mdtnavigation

import android.annotation.SuppressLint
import android.content.Context
import android.location.Location
import android.text.TextUtils
import android.util.Log
import android.view.View
import android.widget.Toast
import androidx.core.content.ContextCompat
import com.google.android.gms.maps.model.LatLng
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.google.maps.android.SphericalUtil
import com.mapbox.android.core.location.LocationEngine
import com.mapbox.android.core.location.LocationEngineProvider
import com.mapbox.android.gestures.MoveGestureDetector
import com.mapbox.api.directions.v5.DirectionsCriteria
import com.mapbox.api.directions.v5.models.DirectionsResponse
import com.mapbox.api.directions.v5.models.RouteOptions
import com.mapbox.bindgen.Expected
import com.mapbox.geojson.Point
import com.mapbox.maps.CameraOptions
import com.mapbox.maps.EdgeInsets
import com.mapbox.maps.MapView
import com.mapbox.maps.plugin.LocationPuck2D
import com.mapbox.maps.plugin.animation.camera
import com.mapbox.maps.plugin.animation.easeTo
import com.mapbox.maps.plugin.gestures.OnMoveListener
import com.mapbox.maps.plugin.gestures.addOnMoveListener
import com.mapbox.maps.plugin.locationcomponent.location
import com.mapbox.navigation.base.TimeFormat
import com.mapbox.navigation.base.extensions.applyDefaultNavigationOptions
import com.mapbox.navigation.base.extensions.applyLanguageAndVoiceUnitOptions
import com.mapbox.navigation.base.internal.route.update
import com.mapbox.navigation.base.options.NavigationOptions
import com.mapbox.navigation.base.route.*
import com.mapbox.navigation.base.trip.model.RouteLegProgress
import com.mapbox.navigation.base.trip.model.RouteProgress
import com.mapbox.navigation.base.trip.model.RouteProgressState
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.MapboxNavigationProvider
import com.mapbox.navigation.core.TripSessionResetCallback
import com.mapbox.navigation.core.arrival.ArrivalObserver
import com.mapbox.navigation.core.directions.session.RoutesObserver
import com.mapbox.navigation.core.formatter.MapboxDistanceFormatter
import com.mapbox.navigation.core.replay.MapboxReplayer
import com.mapbox.navigation.core.replay.ReplayLocationEngine
import com.mapbox.navigation.core.replay.route.ReplayProgressObserver
import com.mapbox.navigation.core.trip.session.*
import com.mapbox.navigation.ui.base.util.MapboxNavigationConsumer
import com.mapbox.navigation.ui.maneuver.api.MapboxManeuverApi
import com.mapbox.navigation.ui.maneuver.view.MapboxManeuverView
import com.mapbox.navigation.ui.maps.camera.NavigationCamera
import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource
import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowView
import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowOptions
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineApi
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView
import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineOptions
import com.mapbox.navigation.ui.maps.route.line.model.NavigationRouteLine
import com.mapbox.navigation.ui.tripprogress.api.MapboxTripProgressApi
import com.mapbox.navigation.ui.tripprogress.model.*
import com.mapbox.navigation.ui.tripprogress.view.MapboxTripProgressView
import com.mapbox.navigation.ui.voice.api.MapboxSpeechApi
import com.mapbox.navigation.ui.voice.api.MapboxVoiceInstructionsPlayer
import com.mapbox.navigation.ui.voice.model.SpeechAnnouncement
import com.mapbox.navigation.ui.voice.model.SpeechError
import com.mapbox.navigation.ui.voice.model.SpeechValue
import java.util.*


class MapApplication constructor(var mapView: MapView, var maneuverView: MapboxManeuverView?) :
    KLocationObserver {
    private var destination: Point? = null

    var isNavigationInProgress = false
    var navigationRouteId: Long? = null
    private var isFirstTime = true
    private var mapCameraRecenterTimer = 0L
    private val MAPBOX_DELAY_TIMER: Long = 5000
    private var lastOffrouteTime: Long = 0
    private val OFF_ROUTE_RETRY: Long = 5000
    val MAPBOX_ACCESS_TOKEN = mapView.context.getString(R.string.mapbox_access_token)

    var lastCurrentLocation: LatLng? = null
    private var lastDestinationPointOverall: Point? = null
    private lateinit var context: Context

    /**
     * [NavigationLocationProvider] is a utility class that helps to provide location updates generated by the Navigation SDK
     * to the Maps SDK in order to update the user location indicator on the map.
     */
    private val navigationLocationProvider = NavigationLocationProvider()


    /**
     * Mapbox Navigation entry point. There should only be one instance of this object for the app.
     * You can use [MapboxNavigationProvider] to help create and obtain that instance.
     */
    private lateinit var mapboxNavigation: MapboxNavigation

    /**
     * Produces the camera frames based on the location and routing data for the [navigationCamera] to execute.
     */
    private lateinit var viewportDataSource: MapboxNavigationViewportDataSource

    /**
     * Used to execute camera transitions based on the data generated by the [viewportDataSource].
     * This includes transitions from route overview to route following and continuously updating the camera as the location changes.
     */
    private lateinit var navigationCamera: NavigationCamera

    /**
     * Debug tool used to play, pause and seek route progress events that can be used to produce mocked location updates along the route.
     */
    private val mapboxReplayer = MapboxReplayer()

    /**
     * Debug tool that mocks location updates with an input from the [mapboxReplayer].
     */
    private val replayLocationEngine = ReplayLocationEngine(mapboxReplayer)

    /**
     * Debug observer that makes sure the replayer has always an up-to-date information to generate mock updates.
     */
    private val replayProgressObserver: ReplayProgressObserver =
        ReplayProgressObserver(mapboxReplayer)

    /**
     * Generates updates for the [routeArrowView] with the geometries and properties of maneuver arrows that should be drawn on the map.
     */
    private val routeArrowApi: MapboxRouteArrowApi = MapboxRouteArrowApi()

    /**
     * Generates updates for the [routeLineView] with the geometries and properties of the routes that should be drawn on the map.
     */
    private lateinit var routeLineApi: MapboxRouteLineApi

    /**
     * Draws route lines on the map based on the data from the [routeLineApi]
     */
    private lateinit var routeLineView: MapboxRouteLineView

    /**
     * Extracts message that should be communicated to the driver about the upcoming maneuver.
     * When possible, downloads a synthesized audio file that can be played back to the driver.
     */
    private lateinit var speechApi: MapboxSpeechApi

    private var haveDeparted = false


    private var onCameraIdleListener: OnCameraIdleListener? = null


    lateinit var listOfChunks: List<List<Point>>
    lateinit var currentList: List<Point>
    var currentIndex = -1

    /**
     * Gets notified with progress along the currently active route.
     */
    private val routeProgressObserver: RouteProgressObserver =
        RouteProgressObserver { routeProgress -> // update the camera position to account for the progressed fragment of the route
            Log.d("MapApplication", "---------------")
            val fractionTraveled = routeProgress.fractionTraveled
            Log.d("MapApplication", "Fraction Traveled: $fractionTraveled")

            // Update the map with the current progress (arrows, polylines, etc.)
//            updateProgressOnTheMap(routeProgress)

//            val remainingDistance = routeProgress.distanceRemaining
//            val remainingTime = routeProgress.durationRemaining

//            Log.d("MapApplication", "Remaining Distance: $remainingDistance meters")
//            Log.d("MapApplication", "Remaining Time: $remainingTime seconds")
//            Log.d("MapApplication", "Route Progress State: ${routeProgress.currentState}")
//
            updateProgressOnTheMap(routeProgress)
            val arrival = Calendar.getInstance()
            arrival.add(Calendar.SECOND, routeProgress.durationRemaining.toInt())

//            if (routeProgress.currentState == RouteProgressState.COMPLETE || remainingDistance <= 10) {
//                Log.d("MapApplication", "Route is complete or vehicle is near the destination.")
//                onUserApproachingDestination()
//            }

            updateApplicationState(routeProgress, arrival)

            if (lastCurrentLocation != null) {
                val distanceInMeters = SphericalUtil.computeDistanceBetween(
                    LatLng(
                        lastCurrentLocation!!.latitude,
                        lastCurrentLocation!!.longitude
                    ), LatLng(destination!!.latitude(), destination!!.longitude())
                )
                Log.d(
                    "MapApplication",
                    "Current LatLng: ${lastCurrentLocation!!.latitude}, ${lastCurrentLocation!!.longitude}"
                )
                Log.d("MapApplication", "Distance:: ${distanceInMeters}")


                if (fractionTraveled >= 0.80) {
                    if (isLastRound() && fractionTraveled >= 0.96) {
                        stopListenerThing()
                        isNavigationInProgress = false
                        updateListRoute({
                            drawFirstTime = true
                        })
                    } else {
                        Log.d(
                            "MapApplication",
                            "User is almost approaching to the section destination"
                        )
                        stopListenerThing()
                        isNavigationInProgress = false
                        updateListRoute({
                            drawFirstTime = true
                        })
                    }
                }
            }

        }

    private fun updateApplicationState(routeProgress: RouteProgress, arrival: Calendar) {
        if (routeProgress.currentState == RouteProgressState.COMPLETE || routeProgress.fractionTraveled >= 1.0) {
            ApplicationStateData.getInstance().txtArrivalTime = ("--:--")
            ApplicationStateData.getInstance().arrivalTime = (0)
            ApplicationStateData.getInstance().txtRemainingDistance = ("--")
            ApplicationStateData.getInstance().txtRemainingTime = ("--")
            ApplicationStateData.getInstance().setEtaToStop(0.0)

        } else {

            ApplicationStateData.getInstance().txtRemainingDistance =
                (formatDistance(routeProgress.distanceRemaining.toDouble()))

            ApplicationStateData.getInstance().txtRemainingTime =
                (formatTime(routeProgress.durationRemaining))

            ApplicationStateData.getInstance().setEtaToStop(routeProgress.durationRemaining)
            ApplicationStateData.getInstance().arrivalTime = (arrival.timeInMillis)
            ApplicationStateData.getInstance().txtArrivalTime = (
                    String.format(
                        "%1$02d:%2$02d",
                        arrival.get(Calendar.HOUR_OF_DAY),
                        arrival.get(Calendar.MINUTE)
                    )
                    )
        }
    }

    private fun updateProgressOnTheMap(routeProgress: RouteProgress) {
        val style = mapView.getMapboxMap().getStyle()
        if (style != null) {
            val maneuverArrowResult = routeArrowApi.addUpcomingManeuverArrow(routeProgress)
            routeArrowView.renderManeuverUpdate(style, maneuverArrowResult)

            routeLineApi.updateWithRouteProgress(routeProgress) {
                routeLineView.renderRouteLineUpdate(style, it)
            }
        } // update top banner with maneuver instructions
        val maneuvers = maneuverApi.getManeuvers(routeProgress)
        maneuvers.fold({ error ->

        }, {
            maneuverView?.visibility = View.VISIBLE
            maneuverView!!.renderManeuvers(maneuvers)
        })
    }

    /**
     * Gets notified whenever the tracked routes change.
     *
     * A change can mean:
     * - routes get changed with [MapboxNavigation.setRoutes]
     * - routes annotations get refreshed (for example, congestion annotation that indicate the live traffic along the route)
     * - driver got off route and a reroute was executed
     */
    var drawFirstTime = true
    private val routesObserver: RoutesObserver = RoutesObserver { routeUpdateResult ->
        if (routeUpdateResult.navigationRoutes.isNotEmpty()) { // generate route geometries asynchronously and render them
            if (drawFirstTime) {
                drawFirstTime = false
                val routeLines =
                    routeUpdateResult.navigationRoutes.map { NavigationRouteLine(it, null) }

                routeLineApi.setNavigationRouteLines(routeLines) { value ->
                    mapView.getMapboxMap().getStyle()?.apply {
                        routeLineView.renderRouteDrawData(
                            this,
                            value
                        )
                    }
                }
                viewportDataSource.onRouteChanged(routeUpdateResult.navigationRoutes.first())
                viewportDataSource.evaluate()
            }
        } else {
            clearRoutesAndArrow()
        }

    }

    fun clearRoutesAndArrow() { // remove the route line and route arrow from the map
        val style = mapView.getMapboxMap().getStyle()
        if (style != null) {
            routeLineApi.clearRouteLine { value ->
                routeLineView.renderClearRouteLineValue(
                    style, value
                )
            }
            routeArrowView.render(style, routeArrowApi.clearArrows())
        }
        viewportDataSource.clearRouteData()
        viewportDataSource.evaluate()
    }

    /**
     * When a synthesized audio file was downloaded, this callback cleans up the disk after it was played.
     */
    private val voiceInstructionsPlayerCallback =
        MapboxNavigationConsumer<SpeechAnnouncement> { value -> // remove already consumed file to free-up space
            speechApi.clean(value)
        }

    /**
     * Based on whether the synthesized audio file is available, the callback plays the file
     * or uses the fall back which is played back using the on-device Text-To-Speech engine.
     */
    private val speechCallback =
        MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
            expected.fold({ error -> // play the instruction via fallback text-to-speech engine
                voiceInstructionsPlayer.play(
                    error.fallback, voiceInstructionsPlayerCallback
                )
            }, { value -> // play the sound file from the external generator
                if (isNavigationInProgress) voiceInstructionsPlayer.play(
                    value.announcement, voiceInstructionsPlayerCallback
                )
            })
        }

    /**
     * Observes when a new voice instruction should be played.
     */
    private val voiceInstructionsObserver: VoiceInstructionsObserver =
        VoiceInstructionsObserver { voiceInstructions ->
            if (isNavigationInProgress)
                speechApi.generate(voiceInstructions, speechCallback)
        }

    /*
    *
    *
     */
    private val arrivalObserver = object : ArrivalObserver {
        override fun onFinalDestinationArrival(routeProgress: RouteProgress) {
            Log.d("MapApplication", "Arrived at the final destination.")
            // You can handle other arrival-related tasks here
        }

        override fun onNextRouteLegStart(routeLegProgress: RouteLegProgress) {
            Log.d("MapApplication", "Next route leg started.")
        }

        override fun onWaypointArrival(routeProgress: RouteProgress) {
            Log.d("MapApplication", "Arrived at waypoint.")
        }
    }

    /**
     * Plays the synthesized audio files with upcoming maneuver instructions
     * or uses an on-device Text-To-Speech engine to communicate the message to the driver.
     */
    private lateinit var voiceInstructionsPlayer: MapboxVoiceInstructionsPlayer

    /**
     * Draws maneuver arrows on the map based on the data [routeArrowApi].
     */
    private lateinit var routeArrowView: MapboxRouteArrowView

    /**
     * Generates updates for the [MapboxManeuverView] to display the upcoming maneuver instructions
     * and remaining distance to the maneuver point.
     */
    private lateinit var maneuverApi: MapboxManeuverApi

    /**
     * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to the destination.
     */
    private lateinit var tripProgressApi: MapboxTripProgressApi

    private val offRouteProgressObserver: OffRouteObserver = OffRouteObserver { isOffRoute ->
        if (isOffRoute) {
            Log.d("MapApplication", "Vehicle went off-route, recalculating route.")
            // You can either force recalculation or check the remaining distance manually
        }
    }


    init {

        initMapboxNavigation()

        initPuckLocation()

        initCamera()

        // initialize maneuver arrow view to draw arrows on the map
        val routeArrowOptions =
            RouteArrowOptions.Builder(ApplicationStateData.getInstance().applicationContext).build()
        routeArrowView = MapboxRouteArrowView(routeArrowOptions)

        // initialize route line, the withRouteLineBelowLayerId is specified to place
        // the route line below road labels layer on the map
        // the value of this option will depend on the style that you are using
        // and under which layer the route line should be placed on the map layers stack
        val mapboxRouteLineOptions =
            MapboxRouteLineOptions.Builder(ApplicationStateData.getInstance().applicationContext)
                .withRouteLineBelowLayerId(
                    "road-label"
                )

                .build()
//
//        val mapboxRouteLineOptions = MapboxRouteLineOptions.Builder(context)
//            .withRouteLineBelowLayerId("road-label")
//            .withRouteLineResources(RouteLineResources.Builder()
//                .routeLineColorResources(RouteLineColorResources.Builder().routeDefaultColor(Color.RED).build())
//                .restrictedRoadLineWidth(5.0)
//                .build())
//            .build()
        routeLineApi = MapboxRouteLineApi(mapboxRouteLineOptions)
        routeLineView = MapboxRouteLineView(mapboxRouteLineOptions)

        // make sure to use the same DistanceFormatterOptions across different features
        val distanceFormatterOptions = mapboxNavigation.navigationOptions.distanceFormatterOptions

        // initialize maneuver api that feeds the data to the top banner maneuver view
        maneuverApi = MapboxManeuverApi(MapboxDistanceFormatter(distanceFormatterOptions))

        initVoiceInstructions()

        // initialize bottom progress view
        tripProgressApi = MapboxTripProgressApi(
            TripProgressUpdateFormatter.Builder(ApplicationStateData.getInstance().applicationContext)
                .distanceRemainingFormatter(
                    DistanceRemainingFormatter(distanceFormatterOptions)
                )
                .timeRemainingFormatter(TimeRemainingFormatter(ApplicationStateData.getInstance().applicationContext))
                .percentRouteTraveledFormatter(
                    PercentDistanceTraveledFormatter()
                ).estimatedTimeToArrivalFormatter(
                    EstimatedTimeToArrivalFormatter(
                        ApplicationStateData.getInstance().applicationContext,
                        TimeFormat.NONE_SPECIFIED
                    )
                ).build()
        )

        setupVoiceButton()
    }

    private fun initVoiceInstructions() {
        speechApi = MapboxSpeechApi(
            ApplicationStateData.getInstance().applicationContext,
            MAPBOX_ACCESS_TOKEN,
            Locale.US.toLanguageTag()
        )

        voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(
            ApplicationStateData.getInstance().applicationContext,
            MAPBOX_ACCESS_TOKEN,
            Locale.US.toLanguageTag()
        )
    }

    private fun setupVoiceButton() {
//        voiceToggleButton.setOnCheckedChangeListener { _, isChecked ->
//            voiceInstructionsPlayer.volume(SpeechVolume(if (!isChecked) 1.0f else 0.0f))
//        }
    }

    public fun startNavigation(destination: Point?, encodedPath: String, context: Context) {
        try {
            destination?.let { navigateToFixedRoute(it, encodedPath, context) }
            isNavigationInProgress = true
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @SuppressLint("MissingPermission")
    fun navigateToFixedRoute(destination: Point, encodedPath: String?, context: Context) {
        this.context = context
        val originLocation = ApplicationStateData.getInstance().getCurrentLocation()
        val originPoint = Point.fromLngLat(
            originLocation!!.longitude,
            originLocation!!.latitude
        )

        stopListenerThing()

        val list = DummyContent.listOfTTestLatLng()
//        val list = PolyUtil.decode(encodedPath)

        val finalList = mutableListOf<Point>()
        for (i in 0 until list.size - 1) {
            finalList.add(Point.fromLngLat(list[i].longitude, list[i].latitude))
        }

//        if(finalList.size < 100) {
//            val mapMatching = MapboxMapMatching.builder()
//                .accessToken(MAPBOX_ACCESS_TOKEN)
//                .coordinates(finalList)
//                .voiceInstructions(true)
//                .steps(true)
//                .waypointIndices(0, finalList.size - 1)
//                .bannerInstructions(true)
//                .profile(DirectionsCriteria.PROFILE_DRIVING)
//                .build()
//            mapMatching.enqueueCall(object : Callback<MapMatchingResponse> {
//                override fun onResponse(
//                    call: Call<MapMatchingResponse>,
//                    response: Response<MapMatchingResponse>
//                ) {
//                    if (response.isSuccessful) {
//                        response.body()?.matchings()?.let { matchingList ->
//                            val directionRoute = matchingList[0].toDirectionRoute()
//                            val mapMatch =
//                                if (matchingList.size > 1) matchingList.get(1) else matchingList.get(
//                                    0
//                                )
//                            mapMatch.toDirectionRoute().toNavigationRoute(
//                                RouterOrigin.Custom()
//                            ).apply {
//                                Log.d("MatchedRouteDetails", "Origin: ${this.origin}")
//                                Log.d(
//                                    "MatchedRouteDetails",
//                                    "Destination: ${this.getDestination()}"
//                                )
//                                setRouteAndStartNavigation(listOf(this))
//                            }
//                        }
//
//                    }
//                }
//
//                override fun onFailure(call: Call<MapMatchingResponse>, t: Throwable) {
//                }
//            })
//
//        } else {
//            Log.d(TAG,"Drawing normal Reservation")
//            findRoute(finalList.first(), finalList.last())
//        }


        Log.e("MapApplication", Gson().toJson(finalList.size.toString()))
//        val filteredList = filterClosePoints(
//            finalList,
//            distanceThreshold = 10.0
//        )  // Example distanceThreshold = 20 meters

//        listOfChunks = finalList.chunked(15)
        listOfChunks = finalList.chunked(15)
        Log.e("MapApplication", Gson().toJson(listOfChunks.size.toString()))
        Log.e("MapApplication", Gson().toJson(finalList.size.toString()))
        Log.e("MapApplication", Gson().toJson(listOfChunks))
        Log.e("MapApplication", Gson().toJson(originPoint))

        updateListRoute({})
    }

    private fun updateListRoute(onSuccessfullDraw: () -> Unit) {
        Log.e("MapApplication", "${currentIndex + 1} < ${listOfChunks.size}")
        if ((currentIndex + 1) < listOfChunks.size) {
            currentIndex = currentIndex + 1
            lastDestinationPointOverall = listOfChunks.get(currentIndex).last()

            currentList = listOfChunks.get(currentIndex)
            destination = currentList.last()

            findRoute(onSuccessfullDraw)
        } else {
            Toast.makeText(context, "Trip demostration Completed", Toast.LENGTH_SHORT).show()
            Log.e("MapApplication", "NO Route Found")
            stopListenerThing()
        }
    }


    fun clearRoute() {
        mapboxNavigation.stopTripSession()
        mapboxNavigation.setNavigationRoutes(emptyList())
    }

    // Example usage
    private fun filterPoints(originalList: List<LatLng>): List<Point> {
        val filteredList = mutableListOf<Point>()
        val distanceThreshold = 20.0

        originalList.forEachIndexed { index, latLng ->
            // Skip the first point
            if (index == 0 || index == originalList.size - 1) {
                filteredList.add(Point.fromLngLat(latLng.longitude, latLng.latitude))
            } else {
                val previousLatLng = originalList[index - 1]
                val distance = haversine(
                    previousLatLng.latitude,
                    previousLatLng.longitude,
                    latLng.latitude,
                    latLng.longitude
                )

                if (distance >= distanceThreshold) {
                    filteredList.add(Point.fromLngLat(latLng.longitude, latLng.latitude))
                }
            }
        }

        return filteredList
    }

    fun haversine(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val R = 6371000.0 // Earth radius in meters
        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)
        val a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2)
        val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
        return R * c
    }

    private fun unregisterObservers() {
        mapboxNavigation.unregisterRoutesObserver(routesObserver)
        mapboxNavigation.unregisterRouteProgressObserver(routeProgressObserver)
        mapboxNavigation.unregisterVoiceInstructionsObserver(voiceInstructionsObserver)
        mapboxNavigation.unregisterOffRouteObserver(offRouteProgressObserver)
        mapboxNavigation.unregisterArrivalObserver(arrivalObserver)
    }

    fun registerLocationObserver() {
        ApplicationStateData.getInstance().registerLocationObserver(this)
    }

    private fun registerObserver() {
        mapboxNavigation.registerRoutesObserver(routesObserver)
        mapboxNavigation.registerRouteProgressObserver(routeProgressObserver)
        mapboxNavigation.registerVoiceInstructionsObserver(voiceInstructionsObserver)
        mapboxNavigation.registerOffRouteObserver(offRouteProgressObserver)
        mapboxNavigation.registerArrivalObserver(arrivalObserver)
        mapboxNavigation.registerBannerInstructionsObserver { bannerInstructions ->

            // Check if the top banner instruction contains the text you want to modify
            Log.e("Instruction", bannerInstructions.primary().text())
//            if (bannerInstructions.primary().text().contains("You will arrive at your destination")) {
//                // Modify the top direction text
//                val updatedText = "Arriving at your point" // Your new instruction text
//                bannerInstructions.primary().toBuilder().text(updatedText)
//            }

            // Update the UI with the modified or original instructions
//            updateBannerText(bannerInstructions.primary().text)
        }
    }

    private fun initCamera() {
        viewportDataSource = MapboxNavigationViewportDataSource(mapView.getMapboxMap())

        ApplicationStateData.getInstance().getCurrentLocation()
            .let { viewportDataSource.onLocationChanged(it) }
        navigationCamera = NavigationCamera(
            mapView.getMapboxMap(), mapView.camera, viewportDataSource
        )
        viewportDataSource.evaluate()
    }

//    private fun initMapboxNavigation() {
//        mapboxNavigation = if (MapboxNavigationProvider.isCreated()) {
//            MapboxNavigationProvider.retrieve()
//        } else {
//            MapboxNavigationProvider.create(
//                NavigationOptions.Builder(ApplicationStateData.getInstance().applicationContext)
//                    .accessToken(MAPBOX_ACCESS_TOKEN).locationEngine(
//                        LocationEngine().getBestLocationEngine(ApplicationStateData.getInstance().applicationContext)
//                    )
//                    .build()
//            )
//        }
//    }
//    private fun initMapboxNavigation() {
//        mapboxNavigation = if (MapboxNavigationProvider.isCreated()) {
//            MapboxNavigationProvider.retrieve()
//        } else {
//            // Use LocationEngineProvider to get the best location engine
//            val locationEngine = LocationEngineProvider.getBestLocationEngine(
//                ApplicationStateData.getInstance().applicationContext
//            )
//
//            // Build the NavigationOptions with the access token and the location engine
//            val navigationOptions = NavigationOptions.Builder(
//                ApplicationStateData.getInstance().applicationContext
//            )
//                .accessToken(MAPBOX_ACCESS_TOKEN)
//                .locationEngine(locationEngine) // Use the correct location engine instance
//                .build()
//
//            // Create MapboxNavigation instance
//            MapboxNavigationProvider.create(navigationOptions)
//        }
//    }

    private fun initMapboxNavigation() {
        // Use LocationEngine to obtain the best location provider
        val locationEngine: LocationEngine = LocationEngineProvider.getBestLocationEngine(
            ApplicationStateData.getInstance().applicationContext
        )

        // Build NavigationOptions with the access token and location engine
        val navigationOptions = NavigationOptions.Builder(
            ApplicationStateData.getInstance().applicationContext
        )
            .accessToken(MAPBOX_ACCESS_TOKEN)
            .locationEngine(locationEngine) // Set the location engine
            .build()

        // Initialize MapboxNavigation with NavigationOptions
        mapboxNavigation = MapboxNavigationProvider.create(navigationOptions)
    }

    private fun initPuckLocation() {
        mapView.location.apply {
            this.locationPuck = LocationPuck2D(
                bearingImage = ContextCompat.getDrawable(
                    ApplicationStateData.getInstance().applicationContext,
                    com.mapbox.navigation.R.drawable.mapbox_navigation_puck_icon
                )
            )
            setLocationProvider(navigationLocationProvider)
            enabled = true
        }


        mapView.getMapboxMap().addOnMoveListener(object : OnMoveListener {
            override fun onMove(detector: MoveGestureDetector): Boolean {
                onCameraIdleListener?.onCameraIdle(null)
                return false
            }

            override fun onMoveBegin(detector: MoveGestureDetector) {
                onCameraIdleListener?.onCameraIdle(null)
            }

            override fun onMoveEnd(detector: MoveGestureDetector) {
                val option = mapView.getMapboxMap().cameraState.center
                if (option.latitude() > 0.0 && option.longitude() > 0.0) {
                    onCameraIdleListener?.let {
                        it.onCameraIdle(Location("").also {
                            it.latitude = option.latitude()
                            it.longitude = option.longitude()
                        })
                    }
                } else {
                    onCameraIdleListener?.onCameraIdle(null)
                }
            }
        })


    }


    private fun filterClosePoints(points: List<Point>, distanceThreshold: Double): List<Point> {
        val filteredPoints = mutableListOf<Point>()
        points.forEachIndexed { index, point ->
            if (index == 0 || index == points.size - 1) {
                filteredPoints.add(point)
            } else {
                val previousPoint = points[index - 1]
                val distance = haversine(
                    previousPoint.latitude(),
                    previousPoint.longitude(),
                    point.latitude(),
                    point.longitude()
                )
                if (distance >= distanceThreshold) {
                    filteredPoints.add(point)
                }
            }
        }
        return filteredPoints
    }

    private fun findRoute(onSuccessfullDraw: () -> Unit) {

        Log.d("MapApplication", "Current LatLng List: ${currentList.size}")
        Log.d("MapApplication", "Current LatLng List: ${currentIndex}")

        if (navigationRouteId != null) {
            mapboxNavigation.cancelRouteRequest(navigationRouteId!!)
        }


        startListenerThing()

        Log.e("MapApplication", (0 until currentList.size).toList().toString())
        Log.e("MapApplication", "Size: " + (currentList.size).toString())
        Log.e(
            "MapApplication",
            "Coordinate: " + currentList.last().latitude() + "," + currentList.last().longitude()
        )
        val list = currentList.subList(1, currentList.size - 1)

        navigationRouteId = mapboxNavigation.requestRoutes(
            RouteOptions.builder().applyDefaultNavigationOptions()
                .applyLanguageAndVoiceUnitOptions(context)
//                .coordinates(origin = currentList.first(), destination = currentList.last())
                .coordinatesList(currentList)
//                .waypointTargetsList(currentList)
                .waypointIndicesList(listOf(0, currentList.size - 1))
                .profile(DirectionsCriteria.PROFILE_DRIVING)
                .bannerInstructions(true)
                .annotationsList(
                    listOf(
                        DirectionsCriteria.ANNOTATION_CONGESTION_NUMERIC,
                        DirectionsCriteria.ANNOTATION_DISTANCE,
                    )
                )
                .geometries(DirectionsCriteria.GEOMETRY_POLYLINE)
                .voiceInstructions(true)
                .steps(true)
                .alternatives(false)
                .enableRefresh(false)
                .build(),

//        navigationRouteId =
//            mapboxNavigation.requestRoutes(
//                RouteOptions.builder().applyDefaultNavigationOptions()
//                    .applyLanguageAndVoiceUnitOptions(
//                        ApplicationStateData.getInstance().applicationContext
//                    ).coordinatesList(currentList)
//                    .waypointIndicesList(listOf(0, currentList.size-1))
//// provide the bearing for the origin of the request to ensure
//                    // that the returned route faces in the direction of the current user movement
//                    .build(),

            object : NavigationRouterCallback {

                override fun onRoutesReady(
                    routes: List<NavigationRoute>,
                    routerOrigin: RouterOrigin
                ) {
                    Log.d(
                        "Route Info",
                        "Route geometry: ${routes.first().routeOptions.geometries()}"
                    )
                    Log.e("Instruction", "${currentIndex}==${listOfChunks.size - 1}")
                    val newRoutes = if (isLastRound()) {
                        routes
                    } else {
                        updateContent(routes)
                    }
//                    val gsopnData = Gson().toJson(routerOrigin)
                    val gsopnData1 = Gson().toJson(newRoutes)
                    Log.e("Instruction", gsopnData1)

                    setRouteAndStartNavigation(listOf(newRoutes.first()))
                    renderRouteOnMap(newRoutes.first())
                    isNavigationInProgress = true
                    onSuccessfullDraw()
                }

                override fun onFailure(
                    reasons: List<RouterFailure>,
                    routeOptions: RouteOptions
                ) {
                    Log.e("MapApplication", "onFailure")
                }

                override fun onCanceled(
                    routeOptions: RouteOptions,
                    routerOrigin: RouterOrigin
                ) { // no impl
                    Log.e("MapApplication", "onCanceled")
                }
            })

    }

    /*    private fun updateContent(routes: List<NavigationRoute>): List<NavigationRoute> {
             routes.forEach { route ->
                // Iterate over each leg
                route.directionsResponse.routes().forEach { directionRoute ->
                    directionRoute.legs()?.forEach { leg ->
                        // Iterate over each step
                        leg.steps()?.forEach { step ->
                            // Iterate over banner instructions
                            step.bannerInstructions()?.forEach { instruction ->
                                val primaryInstruction = instruction.primary()

                                if (primaryInstruction.text().contains("destination", true)) {

                                    val updatedText = primaryInstruction.text().replace("destination", "point", true)

                                    val updatedPrimary = primaryInstruction.toBuilder()
                                        .text(updatedText)
                                        .build()

                                    instruction.toBuilder()
                                        .primary(updatedPrimary)
                                        .build()
                                }

                                primaryInstruction.components()?.forEach { component ->
                                    if (component.text().contains("destination", true)) {
                                        // Create the updated component with the modified text
                                        val updatedText =
                                            component.text().replace("destination", "point", true)
                                        val updatedComponent =
                                            component.toBuilder().text(updatedText).build()

                                        // Rebuild the primary instruction with the updated component
                                        val updatedPrimary = primaryInstruction.toBuilder()
                                            .components(listOf(updatedComponent)) // Replace the component list
                                            .build()

                                        // Set the updated primary instruction to the banner instruction
                                        instruction.toBuilder().primary(updatedPrimary).build()
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return routes

            // Return the updated route
    //            updatedRoute.build()
    //        return routes.map { route ->
    //            if (route.directionsResponse.routes().get(0).legs()!!.get(0).steps().get(0).bannerInstructions().get(0).primary().components().get(0).toBuilder().text().contains("destination")){
    //                var newContent = route.directionsResponse.routes().get(0).legs()!!.get(0).steps().get(0).bannerInstructions().get(0).primary().components().get(0).text()
    //                newContent = newContent.replace("destination","points")
    //                route.directionsResponse.routes().get(0).legs()!!.get(0).steps().get(0).bannerInstructions().get(0).primary().components().get(0).toBuilder().text(newContent)
    //            }


    //        val strContent = Gson().toJson(routes)
    //
    //        if (strContent.contains("destination", true)) {
    //            val newContent = strContent.replace("destination", "point", true)
    //            val listType = object : TypeToken<List<NavigationRoute>>() {}.type
    //            val navigationRoutes: List<NavigationRoute> = Gson().fromJson(newContent, listType)
    //            return navigationRoutes
    //        } else {
    //            return routes
    //        }
        }*/

    private fun isLastRound(): Boolean {
        return currentIndex == listOfChunks.size - 1
    }

    private fun updateContent(routes: List<NavigationRoute>): List<NavigationRoute> {
        val updatedRoutes = mutableListOf<NavigationRoute>()

        routes.forEach { route ->
            val updatedDirectionRoutes = route.directionsResponse.routes().map { directionRoute ->
                val updatedLegs = directionRoute.legs()?.map { leg ->
                    val updatedSteps = leg.steps()?.map { step ->

                        // Update the maneuver instruction
                        val updatedManeuver = step.maneuver().let { maneuver ->
                            if (maneuver.instruction()!!
                                    .contains("You will arrive at your destination", true)
                            ) {
                                maneuver.toBuilder()
                                    .instruction(
                                        maneuver.instruction()!!.replace(
                                            "You will arrive at your destination",
                                            "Continue",
                                            true
                                        )
                                    )
                                    .build()
                            } else if (maneuver.instruction()!!
                                    .contains("You have arrived at your destination", true)
                            ) {
                                maneuver.toBuilder()
                                    .instruction(
                                        maneuver.instruction()!!.replace(
                                            "You have arrived at your destination",
                                            "Continue",
                                            true
                                        )
                                    )
                                    .build()
                            } else {
                                maneuver
                            }
                        }

                        val updatedBannerInstructions =
                            step.bannerInstructions()?.map { instruction ->
                                // Update primary instruction text
                                val updatedPrimary = instruction.primary().let { primary ->
                                    if (primary.text()
                                            .contains("You will arrive at your destination", true)
                                    ) {
                                        primary.toBuilder()
                                            .text(
                                                primary.text().replace(
                                                    "You will arrive at your destination",
                                                    "Continue",
                                                    true
                                                )
                                            )
                                            .build()
                                    } else if (primary.text()
                                            .contains("You have arrived at your destination", true)
                                    ) {
                                        primary.toBuilder()
                                            .text(
                                                primary.text().replace(
                                                    "You have arrived at your destination",
                                                    "Continue",
                                                    true
                                                )
                                            )
                                            .build()
                                    } else {
                                        primary
                                    }
                                }

                                // Update components if necessary
                                val updatedComponents =
                                    updatedPrimary.components()?.map { component ->
                                        if (component.text().contains(
                                                "You will arrive at your destination",
                                                true
                                            )
                                        ) {
                                            component.toBuilder()
                                                .text(
                                                    component.text().replace(
                                                        "You will arrive at your destination",
                                                        "Continue",
                                                        true
                                                    )
                                                )
                                                .build()
                                        } else if (component.text().contains(
                                                "You have arrived at your destination",
                                                true
                                            )
                                        ) {
                                            component.toBuilder()
                                                .text(
                                                    component.text().replace(
                                                        "You have arrived at your destination",
                                                        "Continue",
                                                        true
                                                    )
                                                )
                                                .build()
                                        } else {
                                            component
                                        }
                                    }

                                // Rebuild the primary instruction with updated components
                                val finalPrimaryInstruction = updatedPrimary.toBuilder()
                                    .components(updatedComponents ?: updatedPrimary.components())
                                    .build()

                                // Rebuild the banner instruction with the updated primary instruction
                                instruction.toBuilder()
                                    .primary(finalPrimaryInstruction)
                                    .build()
                            }

                        // Update voice instructions
                        val updatedVoiceInstructions =
                            step.voiceInstructions()?.map { voiceInstruction ->
                                val updatedAnnouncement = if (voiceInstruction.announcement()!!
                                        .contains("You will arrive at your destination", true)
                                ) {
                                    voiceInstruction.toBuilder()
                                        .announcement(
                                            voiceInstruction.announcement()!!.replace(
                                                "You will arrive at your destination",
                                                "Continue",
                                                true
                                            )
                                        )
                                        .ssmlAnnouncement(
                                            voiceInstruction.ssmlAnnouncement()!!.replace(
                                                "You will arrive at your destination",
                                                "Continue",
                                                true
                                            )
                                        )
                                        .build()
                                } else if (voiceInstruction.announcement()!!
                                        .contains("You have arrived at your destination", true)
                                ) {
                                    voiceInstruction.toBuilder()
                                        .announcement(
                                            voiceInstruction.announcement()!!.replace(
                                                "You have arrived at your destination",
                                                "Continue",
                                                true
                                            )
                                        )
                                        .ssmlAnnouncement(
                                            voiceInstruction.ssmlAnnouncement()!!.replace(
                                                "You have arrived at your destination",
                                                "Continue",
                                                true
                                            )
                                        )
                                        .build()
                                } else {
                                    voiceInstruction
                                }
                                updatedAnnouncement
                            }

                        // Rebuild the step with the updated banner instructions
                        step.toBuilder()
                            .bannerInstructions(updatedBannerInstructions!!)
                            .maneuver(updatedManeuver)
                            .voiceInstructions(updatedVoiceInstructions!!)
                            .build()

                    }

                    // Rebuild the leg with the updated steps
                    leg.toBuilder()
                        .steps(updatedSteps)
                        .build()
                }

                // Rebuild the direction route with the updated legs
                directionRoute.toBuilder()
                    .legs(updatedLegs)
                    .build()
            }

            // Rebuild the directions response with the updated routes
            val updatedDirectionsResponse = route.directionsResponse.toBuilder()
                .routes(updatedDirectionRoutes)
                .build()

            // Recreate the NavigationRoute using the updated DirectionsResponse
            val newRoutes = NavigationRoute.create(
                updatedDirectionsResponse,
                route.routeOptions,
                route.origin
            )

            // Add the new routes to the updated list
            updatedRoutes.addAll(newRoutes)
        }

        return updatedRoutes
    }


    @SuppressLint("MissingPermission")
    private fun setRouteAndStartNavigation(routes: List<NavigationRoute>) { // set routes, where the first route in the list is the primary route that
        mapboxNavigation.setNavigationRoutes(routes)
        navigationCamera.requestNavigationCameraToFollowing()
        mapboxNavigation.startTripSession(false)
    }

    private fun renderRouteOnMap(route: NavigationRoute) {
        val routeLines = listOf(NavigationRouteLine(route, null))
        routeLineApi.setNavigationRouteLines(routeLines) { value ->
            mapView.getMapboxMap().getStyle()?.apply {
                routeLineView.renderRouteDrawData(this, value)
            }
        }
    }

    @SuppressLint("MissingPermission")
    fun onStart() {

        if (::mapboxNavigation.isInitialized && mapboxNavigation.isDestroyed.not()) {
            //and recenter camera in Trip Session
            drawFirstTime = true
            startListenerThing()
            //processNavigation()
        } else {

        }
    }

    fun startListenerThing() {
        registerLocationObserver()
        registerObserver()

    }

    fun stopListenerThing() {

        unregisterObservers()

        if (::voiceInstructionsPlayer.isInitialized) {
            voiceInstructionsPlayer.clear()
            voiceInstructionsPlayer.shutdown()
        }
        if (::speechApi.isInitialized) {
            speechApi.cancel()
        }

        mapboxNavigation.stopTripSession()
        mapboxNavigation.resetTripSession(object : TripSessionResetCallback {
            override fun onTripSessionReset() {

            }
        })

        clearRoutesAndArrow()

    }

    fun onStop() {
        if (::mapboxNavigation.isInitialized || mapboxNavigation.isDestroyed.not()) {
            mapboxNavigation.resetTripSession()
            mapboxNavigation.setNavigationRoutes(emptyList())
            unregisterObservers()
            ApplicationStateData.getInstance().registerLocationObserver(null)
            speechApi.cancel()
            voiceInstructionsPlayer.shutdown()
            clearRoutesAndArrow()
        }
    }

    fun onResume() {
        if (::mapboxNavigation.isInitialized || mapboxNavigation.isDestroyed.not()) {

            onStart()
            if (isNavigationInProgress == true) {
                drawRouteAgain()
            }
        }
    }

//    fun stopNavigation() {
//
//        unregisterObservers()
//        clearRoutesAndArrow()
//
//
//    }

    companion object {
        private val TAG = MapApplication::class.java.simpleName
    }


    private fun formatTime(seconds: Double): String {
        if (seconds < 60) {
            return String.format("%1$.0f sec", seconds)
        }
        if (seconds < (60 * 2)) // less than 2 minutes
        {
            return String.format("%1$.0f min<br>%2$.0f sec", seconds / 60, seconds % 60)
        }

        return if (seconds < (60 * 60)) // less than 1 hour
        {
            String.format("%1$.0f min", seconds / 60, seconds % 60)
        } else {
            String.format(
                "%1$.0f hr<br>%2$.0f min", seconds / (60 * 60), (seconds % (60 * 60)) / 60
            )
        }
    }


    private fun formatDistance(meters: Double): String {
        return if (meters < 1000) {
            String.format("%.0f m", meters);
        } else if (meters < 10000) {
            String.format("%.1f km", meters / 1000.0);
        } else {
            String.format("%.0f km", meters / 1000.0);
        }
    }

    override fun onNewLocation(location: Location?) {

        if (location != null) {
            lastCurrentLocation = LatLng(location.latitude, location.longitude)
//            Log.e("MapApplication", "Location: " + location.latitude + "," + location.longitude)
//            val distanceInMeters = SphericalUtil.computeDistanceBetween(
//                LatLng(
//                    location.latitude,
//                    location.longitude
//                ), LatLng(destination!!.latitude(), destination!!.longitude())
//            )
//            Log.d("MapApplication", "Distance:: ${distanceInMeters}")
        }
        navigationLocationProvider.changePosition(
            location = location!!,
            keyPoints = emptyList(),
        )

        if (System.currentTimeMillis() - mapCameraRecenterTimer > MAPBOX_DELAY_TIMER) {
            mapCameraRecenterTimer = System.currentTimeMillis()
            //sanitizeNavigation()

            if (isFirstTime) {
                isFirstTime = false
                viewportDataSource.followingZoomPropertyOverride(17.0)
                viewportDataSource.followingPadding =
                    EdgeInsets(0.0, 0.0, ImageUtil.dpToPx(250).toDouble(), 0.0)
            }

        }
        navigationCamera.requestNavigationCameraToFollowing()

        if (location != null) {
            viewportDataSource.onLocationChanged(location)
        }
        viewportDataSource.evaluate()
    }

//    private fun onUserReachedDestination() {
//        stopNavigation()
//        Log.d("MapApplication", "User has arrived at the destination!")
//    }

    fun setCurrentLocation(location: Location?) {
        location?.let {
            mapView.getMapboxMap().easeTo(
                CameraOptions.Builder()
                    .center(Point.fromLngLat(location.longitude, location.latitude))
                    .zoom(17.0)
                    .padding(EdgeInsets(500.0, 0.0, 0.0, 0.0))
                    .build()
            )


        }
    }


    fun registerCameraMoveLocationObserver(listener: OnCameraIdleListener) {
        onCameraIdleListener = listener
    }

    interface OnCameraIdleListener {
        fun onCameraIdle(location: Location?)
    }

    fun drawRouteAgain() {
        findRoute({})
    }
}