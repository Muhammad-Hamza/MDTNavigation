package com.karwa.mdtnavigation

import android.annotation.SuppressLint
import android.location.Location
import android.util.Log
import android.view.View
import android.widget.Toast
import androidx.core.content.ContextCompat
import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.tasks.CancellationTokenSource
import com.google.maps.android.PolyUtil
import com.mapbox.android.core.location.LocationEngineProvider
import com.mapbox.android.gestures.MoveGestureDetector
import com.mapbox.api.directions.v5.DirectionsCriteria
import com.mapbox.api.directions.v5.models.Bearing
import com.mapbox.api.directions.v5.models.DirectionsRoute
import com.mapbox.api.directions.v5.models.RouteOptions
import com.mapbox.api.matching.v5.MapboxMapMatching
import com.mapbox.api.matching.v5.models.MapMatchingResponse
import com.mapbox.bindgen.Expected
import com.mapbox.geojson.Point
import com.mapbox.maps.CameraOptions
import com.mapbox.maps.EdgeInsets
import com.mapbox.maps.MapView
import com.mapbox.maps.plugin.LocationPuck2D
import com.mapbox.maps.plugin.animation.camera
import com.mapbox.maps.plugin.animation.easeTo
import com.mapbox.maps.plugin.gestures.OnMoveListener
import com.mapbox.maps.plugin.gestures.addOnMoveListener
import com.mapbox.maps.plugin.locationcomponent.location
import com.mapbox.navigation.base.TimeFormat
import com.mapbox.navigation.base.extensions.applyDefaultNavigationOptions
import com.mapbox.navigation.base.extensions.applyLanguageAndVoiceUnitOptions
import com.mapbox.navigation.base.formatter.UnitType
import com.mapbox.navigation.base.options.NavigationOptions
import com.mapbox.navigation.base.route.*
import com.mapbox.navigation.base.trip.model.RouteLegProgress
import com.mapbox.navigation.base.trip.model.RouteProgress
import com.mapbox.navigation.base.trip.model.RouteProgressState
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.MapboxNavigationProvider
import com.mapbox.navigation.core.arrival.ArrivalObserver
import com.mapbox.navigation.core.directions.session.RoutesObserver
import com.mapbox.navigation.core.formatter.MapboxDistanceFormatter
import com.mapbox.navigation.core.replay.MapboxReplayer
import com.mapbox.navigation.core.replay.ReplayLocationEngine
import com.mapbox.navigation.core.replay.route.ReplayProgressObserver
import com.mapbox.navigation.core.trip.session.*
import com.mapbox.navigation.ui.base.util.MapboxNavigationConsumer
import com.mapbox.navigation.ui.maneuver.api.MapboxManeuverApi
import com.mapbox.navigation.ui.maneuver.view.MapboxManeuverView
import com.mapbox.navigation.ui.maps.camera.NavigationCamera
import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource
import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowView
import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowOptions
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineApi
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView
import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineOptions
import com.mapbox.navigation.ui.maps.route.line.model.NavigationRouteLine
import com.mapbox.navigation.ui.tripprogress.api.MapboxTripProgressApi
import com.mapbox.navigation.ui.tripprogress.model.*
import com.mapbox.navigation.ui.tripprogress.view.MapboxTripProgressView
import com.mapbox.navigation.ui.voice.api.MapboxSpeechApi
import com.mapbox.navigation.ui.voice.api.MapboxVoiceInstructionsPlayer
import com.mapbox.navigation.ui.voice.model.SpeechAnnouncement
import com.mapbox.navigation.ui.voice.model.SpeechError
import com.mapbox.navigation.ui.voice.model.SpeechValue
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import java.util.*


class MapApplication constructor(var mapView: MapView, var maneuverView: MapboxManeuverView?) :
    KLocationObserver {
    private var destination: Point? = null

    var isNavigationInProgress = false
    var navigationRouteId: Long? = null
    private var isFirstTime = true
    private var mapCameraRecenterTimer = 0L
    private val MAPBOX_DELAY_TIMER: Long = 5000
    private var lastOffrouteTime: Long = 0
    private val OFF_ROUTE_RETRY: Long = 5000
    val MAPBOX_ACCESS_TOKEN =
        "pk.eyJ1IjoibXVoYW1tYWRoYW16YTAwIiwiYSI6ImNscW1keWV6cjMxMWYybG80eWVtbHNweDQifQ.HYzk_WgxSpJHw3HVDXNjnw"

    /**
     * [NavigationLocationProvider] is a utility class that helps to provide location updates generated by the Navigation SDK
     * to the Maps SDK in order to update the user location indicator on the map.
     */
    private val navigationLocationProvider = NavigationLocationProvider()


    /**
     * Mapbox Navigation entry point. There should only be one instance of this object for the app.
     * You can use [MapboxNavigationProvider] to help create and obtain that instance.
     */
    private lateinit var mapboxNavigation: MapboxNavigation

    /**
     * Produces the camera frames based on the location and routing data for the [navigationCamera] to execute.
     */
    private lateinit var viewportDataSource: MapboxNavigationViewportDataSource

    /**
     * Used to execute camera transitions based on the data generated by the [viewportDataSource].
     * This includes transitions from route overview to route following and continuously updating the camera as the location changes.
     */
    private lateinit var navigationCamera: NavigationCamera

    /**
     * Debug tool used to play, pause and seek route progress events that can be used to produce mocked location updates along the route.
     */
    private val mapboxReplayer = MapboxReplayer()

    /**
     * Debug tool that mocks location updates with an input from the [mapboxReplayer].
     */
    private val replayLocationEngine = ReplayLocationEngine(mapboxReplayer)

    /**
     * Debug observer that makes sure the replayer has always an up-to-date information to generate mock updates.
     */
    private val replayProgressObserver: ReplayProgressObserver =
        ReplayProgressObserver(mapboxReplayer)

    /**
     * Generates updates for the [routeArrowView] with the geometries and properties of maneuver arrows that should be drawn on the map.
     */
    private val routeArrowApi: MapboxRouteArrowApi = MapboxRouteArrowApi()

    /**
     * Generates updates for the [routeLineView] with the geometries and properties of the routes that should be drawn on the map.
     */
    private lateinit var routeLineApi: MapboxRouteLineApi

    /**
     * Draws route lines on the map based on the data from the [routeLineApi]
     */
    private lateinit var routeLineView: MapboxRouteLineView

    /**
     * Extracts message that should be communicated to the driver about the upcoming maneuver.
     * When possible, downloads a synthesized audio file that can be played back to the driver.
     */
    private lateinit var speechApi: MapboxSpeechApi

    private var haveDeparted = false


    private var onCameraIdleListener: OnCameraIdleListener? = null


    /**
     * Gets notified with progress along the currently active route.
     */
    private val routeProgressObserver: RouteProgressObserver =
        RouteProgressObserver { routeProgress -> // update the camera position to account for the progressed fragment of the route
            if (isNavigationInProgress) {
                updateProgressOnTheMap(routeProgress)

                val arrival = Calendar.getInstance()
                arrival.add(Calendar.SECOND, routeProgress.durationRemaining.toInt())

                updateApplicationState(routeProgress, arrival)
            }
        }


    private fun updateApplicationState(routeProgress: RouteProgress, arrival: Calendar) {
        if (routeProgress.currentState == RouteProgressState.COMPLETE || routeProgress.fractionTraveled >= 1.0) {
            stopNavigation()
            ApplicationStateData.getInstance().txtArrivalTime = ("--:--")
            ApplicationStateData.getInstance().arrivalTime = (0)
            ApplicationStateData.getInstance().txtRemainingDistance = ("--")
            ApplicationStateData.getInstance().txtRemainingTime = ("--")
            ApplicationStateData.getInstance().setEtaToStop(0.0)

        } else {

            ApplicationStateData.getInstance().txtRemainingDistance =
                (formatDistance(routeProgress.distanceRemaining.toDouble()))

            ApplicationStateData.getInstance().txtRemainingTime =
                (formatTime(routeProgress.durationRemaining))

            ApplicationStateData.getInstance().setEtaToStop(routeProgress.durationRemaining)
            ApplicationStateData.getInstance().arrivalTime = (arrival.timeInMillis)
            ApplicationStateData.getInstance().txtArrivalTime = (
                    String.format(
                        "%1$02d:%2$02d",
                        arrival.get(Calendar.HOUR_OF_DAY),
                        arrival.get(Calendar.MINUTE)
                    )
                    )
        }
    }

    private fun updateProgressOnTheMap(routeProgress: RouteProgress) {
        val style = mapView.getMapboxMap().getStyle()
        if (style != null) {
            val maneuverArrowResult = routeArrowApi.addUpcomingManeuverArrow(routeProgress)
            routeArrowView.renderManeuverUpdate(style, maneuverArrowResult)

            routeLineApi.updateWithRouteProgress(routeProgress) {
                routeLineView.renderRouteLineUpdate(style, it)
            }
        } // update top banner with maneuver instructions
        val maneuvers = maneuverApi.getManeuvers(routeProgress)
        maneuvers.fold({ error ->
            Toast.makeText(
                ApplicationStateData.getInstance().applicationContext,
                error.errorMessage,
                Toast.LENGTH_SHORT
            ).show()
        }, {
            maneuverView?.visibility = View.VISIBLE
            maneuverView!!.renderManeuvers(maneuvers)
        })
    }

    /**
     * Gets notified whenever the tracked routes change.
     *
     * A change can mean:
     * - routes get changed with [MapboxNavigation.setRoutes]
     * - routes annotations get refreshed (for example, congestion annotation that indicate the live traffic along the route)
     * - driver got off route and a reroute was executed
     */
    var drawFirstTime = true
    private val routesObserver: RoutesObserver = RoutesObserver { routeUpdateResult ->
        if (routeUpdateResult.navigationRoutes.isNotEmpty()) { // generate route geometries asynchronously and render them
            if (drawFirstTime) {
                drawFirstTime = false
                val routeLines =
                    routeUpdateResult.navigationRoutes.map { NavigationRouteLine(it, null) }

                routeLineApi.setNavigationRouteLines(routeLines) { value ->
                    mapView.getMapboxMap().getStyle()?.apply {
                        routeLineView.renderRouteDrawData(
                            this,
                            value
                        )
                    }
                }
                viewportDataSource.onRouteChanged(routeUpdateResult.navigationRoutes.first())
                viewportDataSource.evaluate()
            }

        } else {
            clearRoutesAndArrow()
        }

    }

    private fun clearRoutesAndArrow() { // remove the route line and route arrow from the map
        val style = mapView.getMapboxMap().getStyle()
        if (style != null) {
            routeLineApi.clearRouteLine { value ->
                routeLineView.renderClearRouteLineValue(
                    style, value
                )
            }
            routeArrowView.render(style, routeArrowApi.clearArrows())
        }
        viewportDataSource.clearRouteData()
        viewportDataSource.evaluate()
    }

    /**
     * When a synthesized audio file was downloaded, this callback cleans up the disk after it was played.
     */
    private val voiceInstructionsPlayerCallback =
        MapboxNavigationConsumer<SpeechAnnouncement> { value -> // remove already consumed file to free-up space
            speechApi.clean(value)
        }

    /**
     * Based on whether the synthesized audio file is available, the callback plays the file
     * or uses the fall back which is played back using the on-device Text-To-Speech engine.
     */
    private val speechCallback =
        MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
            expected.fold({ error -> // play the instruction via fallback text-to-speech engine
                voiceInstructionsPlayer.play(
                    error.fallback, voiceInstructionsPlayerCallback
                )
            }, { value -> // play the sound file from the external generator
                if (isNavigationInProgress) voiceInstructionsPlayer.play(
                    value.announcement, voiceInstructionsPlayerCallback
                )
            })
        }

    /**
     * Observes when a new voice instruction should be played.
     */
    private val voiceInstructionsObserver: VoiceInstructionsObserver =
        VoiceInstructionsObserver { voiceInstructions ->
            if (isNavigationInProgress)
                speechApi.generate(voiceInstructions, speechCallback)
        }

    /*
    *
    *
     */
    private val arrivalObserver = object : ArrivalObserver {
        override fun onFinalDestinationArrival(routeProgress: RouteProgress) {
        }

        override fun onNextRouteLegStart(routeLegProgress: RouteLegProgress) {
        }

        override fun onWaypointArrival(routeProgress: RouteProgress) {
        }

    }

    /**
     * Plays the synthesized audio files with upcoming maneuver instructions
     * or uses an on-device Text-To-Speech engine to communicate the message to the driver.
     */
    private lateinit var voiceInstructionsPlayer: MapboxVoiceInstructionsPlayer

    /**
     * Draws maneuver arrows on the map based on the data [routeArrowApi].
     */
    private lateinit var routeArrowView: MapboxRouteArrowView

    /**
     * Generates updates for the [MapboxManeuverView] to display the upcoming maneuver instructions
     * and remaining distance to the maneuver point.
     */
    private lateinit var maneuverApi: MapboxManeuverApi

    /**
     * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to the destination.
     */
    private lateinit var tripProgressApi: MapboxTripProgressApi

    private val offRouteProgressObserver: OffRouteObserver = OffRouteObserver { isOffRoute ->

    }

    init {

        initMapboxNavigation()

        initPuckLocation()

        initCamera()

        // initialize maneuver arrow view to draw arrows on the map
        val routeArrowOptions =
            RouteArrowOptions.Builder(ApplicationStateData.getInstance().applicationContext).build()
        routeArrowView = MapboxRouteArrowView(routeArrowOptions)

        // initialize route line, the withRouteLineBelowLayerId is specified to place
        // the route line below road labels layer on the map
        // the value of this option will depend on the style that you are using
        // and under which layer the route line should be placed on the map layers stack
        val mapboxRouteLineOptions =
            MapboxRouteLineOptions.Builder(ApplicationStateData.getInstance().applicationContext)
                .withRouteLineBelowLayerId(
                    "road-label"
                ).build()
        routeLineApi = MapboxRouteLineApi(mapboxRouteLineOptions)
        routeLineView = MapboxRouteLineView(mapboxRouteLineOptions)

        // make sure to use the same DistanceFormatterOptions across different features
        val distanceFormatterOptions = mapboxNavigation.navigationOptions.distanceFormatterOptions

        // initialize maneuver api that feeds the data to the top banner maneuver view
        maneuverApi = MapboxManeuverApi(MapboxDistanceFormatter(distanceFormatterOptions))

        initVoiceInstructions()

        // initialize bottom progress view
        tripProgressApi = MapboxTripProgressApi(
            TripProgressUpdateFormatter.Builder(ApplicationStateData.getInstance().applicationContext)
                .distanceRemainingFormatter(
                    DistanceRemainingFormatter(distanceFormatterOptions)
                )
                .timeRemainingFormatter(TimeRemainingFormatter(ApplicationStateData.getInstance().applicationContext))
                .percentRouteTraveledFormatter(
                    PercentDistanceTraveledFormatter()
                ).estimatedTimeToArrivalFormatter(
                EstimatedTimeToArrivalFormatter(
                    ApplicationStateData.getInstance().applicationContext,
                    TimeFormat.NONE_SPECIFIED
                )
            ).build()
        )

        setupVoiceButton()
    }

    private fun initVoiceInstructions() {
        speechApi = MapboxSpeechApi(
            ApplicationStateData.getInstance().applicationContext,
            MAPBOX_ACCESS_TOKEN,
            Locale.US.toLanguageTag()
        )

        voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(
            ApplicationStateData.getInstance().applicationContext,
            MAPBOX_ACCESS_TOKEN,
            Locale.US.toLanguageTag()
        )
    }

    private fun setupVoiceButton() {
//        voiceToggleButton.setOnCheckedChangeListener { _, isChecked ->
//            voiceInstructionsPlayer.volume(SpeechVolume(if (!isChecked) 1.0f else 0.0f))
//        }
    }


    public fun startNavigation(destination: Point?, encodedPath: String) {
        try {
            destination?.let { navigateToFixedRoute(it, encodedPath) }
            isNavigationInProgress = true
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @SuppressLint("MissingPermission")
    fun navigateToFixedRoute(destination: Point, encodedPath: String?) {
        registerObserver()
        val originLocation = ApplicationStateData.getInstance().getCurrentLocation()
        val originPoint = Point.fromLngLat(
            originLocation!!.longitude,
            originLocation!!.latitude
        )
        val list = PolyUtil.decode(encodedPath)

        val finalList = mutableListOf<Point>()
        list.forEach {
            finalList.add(Point.fromLngLat(it.longitude,it.latitude))
        }
//        val finalList = filterPoints(list)
        //finalList.reverse()
       // finalList.add(finalList.size ,originPoint)

        mapboxNavigation.requestRoutes(
            RouteOptions.builder().applyDefaultNavigationOptions()
                .applyLanguageAndVoiceUnitOptions(
                    ApplicationStateData.getInstance().applicationContext
                ).coordinatesList(
                    listOf(finalList.last(),finalList.first())
                ) // provide the bearing for the origin of the request to ensure
                // that the returned route faces in the direction of the current user movement
                .bearingsList(
                    listOf(
                        Bearing.builder().angle(originLocation.bearing.toDouble()).degrees(45.0)
                            .build(),
                        null
                    )
                ).build(),

            object : NavigationRouterCallback {
                override fun onRoutesReady(
                    routes: List<NavigationRoute>,
                    routerOrigin: RouterOrigin
                ) {
                    setRouteAndStartNavigation(routes)
                    isNavigationInProgress = true
                }

                override fun onFailure(
                    reasons: List<RouterFailure>,
                    routeOptions: RouteOptions
                ) {
                }

                override fun onCanceled(
                    routeOptions: RouteOptions,
                    routerOrigin: RouterOrigin
                ) { // no impl
                }
            })


//        val mapMatching = MapboxMapMatching.builder()
//            .accessToken(MAPBOX_ACCESS_TOKEN)
//            .coordinates(finalList)
//            .voiceInstructions(true)
//            .steps(true)
//            .bannerInstructions(true)
//            .profile(DirectionsCriteria.PROFILE_DRIVING)
//            .build()
//
//        mapMatching.enqueueCall(object : Callback<MapMatchingResponse> {
//            override fun onResponse(
//                call: Call<MapMatchingResponse>,
//                response: Response<MapMatchingResponse>
//            ) {
//
//                if (response.isSuccessful) {
//                    response.body()?.matchings()?.let { matchingList ->
//                        matchingList[0].toDirectionRoute().toNavigationRoute(
//                            RouterOrigin.Custom()
//                        ).apply {
//
//
//
////                            setRouteAndStartNavigation(listOf(this))
//                            //mapboxNavigation.setNavigationRoutes(listOf(this))
//                        }
//                    }
//                }
////                if (response.isSuccessful) {
////                    response.body()?.matchings()?.let { matchingList ->
////                        if (matchingList.isNotEmpty()) {
////                            val matchedPoint = matchingList.first()
////                            val directionsRoute = DirectionsRoute.builder()
////                                .legs(matchedPoint.legs())
////                                .duration(matchedPoint.duration())
////                                .distance(matchedPoint.distance())
////                                .routeIndex("0")
////                                .geometry(matchedPoint.geometry())
////                                .routeOptions(
////                                    RouteOptions
////                                        .builder()
////                                        .applyDefaultNavigationOptions()
////                                        .voiceUnits(UnitType.METRIC.value)
////                                        .language(Locale.ENGLISH.toLanguageTag())
////                                        .coordinatesList(
////                                           finalList
////                                        )
////                                        .bearingsList(
////                                            listOf(
////                                                Bearing.builder()
////                                                    .angle(originLocation.bearing.toDouble())
////                                                    .degrees(45.0).build(), null
////                                            )
////                                        )
////                                        .build()
////                                )
////                                .build();
////
////                            //Log.d("MapApplicationDirectionRoute",mapboxNavigation.getNavigationRoutes().toString())
////                            mapboxNavigation.setNavigationRoutes(listOf(directionsRoute.toNavigationRoute(RouterOrigin.Custom)))
////                            mapboxNavigation.startTripSession(true)
////
////
////                        }
////                    }
////                }
//            }
//
//            override fun onFailure(call: Call<MapMatchingResponse>, t: Throwable) {
//                Log.d("MappApplication", t.message!!)
//            }
//        })
    }

    fun clearRoute() {
        mapboxNavigation.stopTripSession()
        mapboxNavigation.setNavigationRoutes(emptyList())
    }

    private fun filterPoints(mList: List<LatLng>): List<Point> {
        val shuffledList = mutableListOf<Point>()

        if (mList.isNotEmpty()) {
            var previousLatLng = mList[0]
            var currentIndex = 1

            while (currentIndex < mList.size) {
                var currentLatLng = mList[currentIndex]

                // Keep updating currentLatLng until the distance is >= 100 meters
                while (haversine(
                        previousLatLng.latitude,
                        previousLatLng.longitude,
                        currentLatLng.latitude,
                        currentLatLng.longitude
                    ) < 100.0
                ) {
                    currentIndex++ // Move to the next point
                    if (currentIndex >= mList.size) {
                        break // Break if we've reached the end of the list
                    }
                    currentLatLng = mList[currentIndex]
                }

                // Add the current point to the shuffled list
                shuffledList.add(Point.fromLngLat(currentLatLng.longitude, currentLatLng.latitude))
                previousLatLng = currentLatLng
            }
        }

        return shuffledList
    }

    fun haversine(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val R = 6371000.0 // Earth radius in meters
        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)
        val a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2)
        val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
        return R * c
    }

    private fun unregisterObservers() {
        mapboxNavigation.unregisterRoutesObserver(routesObserver)
        mapboxNavigation.unregisterRouteProgressObserver(routeProgressObserver)
        mapboxNavigation.unregisterVoiceInstructionsObserver(voiceInstructionsObserver)
        mapboxNavigation.unregisterOffRouteObserver(offRouteProgressObserver)
        mapboxNavigation.unregisterArrivalObserver(arrivalObserver)
    }

    fun registerLocationObserver() {
        ApplicationStateData.getInstance().registerLocationObserver(this)
    }

    private fun registerObserver() {
        mapboxNavigation.registerRoutesObserver(routesObserver)
        mapboxNavigation.registerRouteProgressObserver(routeProgressObserver)
        mapboxNavigation.registerVoiceInstructionsObserver(voiceInstructionsObserver)
        //mapboxNavigation.registerOffRouteObserver(offRouteProgressObserver)
        mapboxNavigation.registerArrivalObserver(arrivalObserver)
    }

    private fun initCamera() {
        viewportDataSource = MapboxNavigationViewportDataSource(mapView.getMapboxMap())

        ApplicationStateData.getInstance().getCurrentLocation()
            .let { viewportDataSource.onLocationChanged(it) }
        navigationCamera = NavigationCamera(
            mapView.getMapboxMap(), mapView.camera, viewportDataSource
        )
        viewportDataSource.evaluate()
    }

    private fun initMapboxNavigation() {
        mapboxNavigation = if (MapboxNavigationProvider.isCreated()) {
            MapboxNavigationProvider.retrieve()
        } else {
            MapboxNavigationProvider.create(
                NavigationOptions.Builder(ApplicationStateData.getInstance().applicationContext)
                    .accessToken(MAPBOX_ACCESS_TOKEN).locationEngine(
                    LocationEngineProvider.getBestLocationEngine(ApplicationStateData.getInstance().applicationContext)
                )
                    .build()
            )
        }
    }

    private fun initPuckLocation() {
        mapView.location.apply {
            this.locationPuck = LocationPuck2D(
                bearingImage = ContextCompat.getDrawable(
                    ApplicationStateData.getInstance().applicationContext,
                    com.mapbox.navigation.R.drawable.mapbox_navigation_puck_icon
                )
            )
            setLocationProvider(navigationLocationProvider)
            enabled = true
        }


        mapView.getMapboxMap().addOnMoveListener(object : OnMoveListener {
            override fun onMove(detector: MoveGestureDetector): Boolean {
                onCameraIdleListener?.onCameraIdle(null)
                return false
            }

            override fun onMoveBegin(detector: MoveGestureDetector) {
                onCameraIdleListener?.onCameraIdle(null)
            }

            override fun onMoveEnd(detector: MoveGestureDetector) {
                val option = mapView.getMapboxMap().cameraState.center
                if (option.latitude() > 0.0 && option.longitude() > 0.0) {
                    onCameraIdleListener?.let {
                        it.onCameraIdle(Location("").also {
                            it.latitude = option.latitude()
                            it.longitude = option.longitude()
                        })
                    }
                } else {
                    onCameraIdleListener?.onCameraIdle(null)
                }
            }
        })


    }

    private fun findRoute(destination: Point) {
        val originLocation = ApplicationStateData.getInstance().getCurrentLocation()
        val originPoint = Point.fromLngLat(
            ApplicationStateData.getInstance().getCurrentLocation()!!.longitude,
            ApplicationStateData.getInstance().getCurrentLocation()!!.latitude
        )


        // execute a route request
        // it's recommended to use the
        // applyDefaultNavigationOptions and applyLanguageAndVoiceUnitOptions
        // that make sure the route request is optimized
        // to allow for support of all of the Navigation SDK features
        navigationRouteId =
            mapboxNavigation.requestRoutes(
                RouteOptions.builder().applyDefaultNavigationOptions()
                    .applyLanguageAndVoiceUnitOptions(
                        ApplicationStateData.getInstance().applicationContext
                    ).coordinatesList(
                    listOf(
                        originPoint,
                        destination
                    )
                ) // provide the bearing for the origin of the request to ensure
                    // that the returned route faces in the direction of the current user movement
                    .bearingsList(
                        listOf(
                            Bearing.builder().angle(originLocation.bearing.toDouble()).degrees(45.0)
                                .build(),
                            null
                        )
                    ).build(),

                object : NavigationRouterCallback {
                    override fun onRoutesReady(
                        routes: List<NavigationRoute>,
                        routerOrigin: RouterOrigin
                    ) {
                        setRouteAndStartNavigation(routes)
                        isNavigationInProgress = true
                    }

                    override fun onFailure(
                        reasons: List<RouterFailure>,
                        routeOptions: RouteOptions
                    ) {
                    }

                    override fun onCanceled(
                        routeOptions: RouteOptions,
                        routerOrigin: RouterOrigin
                    ) { // no impl
                    }
                })
    }

    @SuppressLint("MissingPermission")
    private fun setRouteAndStartNavigation(routes: List<NavigationRoute>) { // set routes, where the first route in the list is the primary route that
        // will be used for active guidance
        mapboxNavigation.setNavigationRoutes(routes)
        navigationCamera.requestNavigationCameraToFollowing()
        mapboxNavigation.startTripSession(false)
    }

//    @SuppressLint("MissingPermission") fun navigate(destination: Point?)
//    {
//        this.destination = destination
//
//        registerObserver()
//
//        try
//        {
//            if (NetworkAvailabilityUtil.isConnected())
//            {
//                val currentLatLng = LocationUtil.getCurrentLatLng()
//                LogUtil.LOGD("MapApplication","Current : ${currentLatLng.lat}, ${currentLatLng.lng}")
//                LogUtil.LOGD("MapApplication","=========================")
//                LogUtil.LOGD("MapApplication","Destination: $destination")
//                isNavigationInProgress = true
//                startNavigation(
//                    Point.fromLngLat(currentLatLng.lng, currentLatLng.lat),
//                    destination
//                )
//            }
//            else LogUtil.LOGE(TAG, "Skipping navigation because of offline mode")
//        } catch (e: Exception)
//        {
//            LogUtil.LOGE(TAG, e.message)
//            e.printStackTrace()
//        }
//    }

    @SuppressLint("MissingPermission")
    fun onStart() {

        if (::mapboxNavigation.isInitialized && mapboxNavigation.isDestroyed.not()) {
            //and recenter camera in Trip Session
            drawFirstTime = true
            registerObserver()
            mapboxNavigation.startTripSession(true)
            //processNavigation()
        } else {

        }
    }

     fun clearNavigation() {
        stopNavigation()
        clearRoutesAndArrow()
    }

    fun onStop() {
        if (::mapboxNavigation.isInitialized || mapboxNavigation.isDestroyed.not()) {
            mapboxNavigation.resetTripSession()
            mapboxNavigation.setNavigationRoutes(emptyList())
            unregisterObservers()
            ApplicationStateData.getInstance().registerLocationObserver(null)
            speechApi.cancel()
            voiceInstructionsPlayer.shutdown()
            clearRoutesAndArrow()
        }
    }

    /**
     * Start navigation between two points and multiple
     * way points
     * multiple way points are also stops so we will also
     * add this in our navigation
     * @param origin this is the starting point for the navigation
     * @param destination this is the ending point for the navigation
     * both origin and destination will keep updating according to
     * the available stops in ride sharing case
     * @param wayPoints is the list of the navigation points from
     * start to end
     * @param context is the calling activity
     */
    public fun startNavigation(origin: Point?, destination: Point?) {
        try {
            destination?.let { findRoute(it) }
            isNavigationInProgress = true
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    fun recenterMap() {
        val cameraOptions = CameraOptions.Builder().center(
            Point.fromLngLat(
                ApplicationStateData.getInstance().getCurrentLocation().longitude,
                ApplicationStateData.getInstance().getCurrentLocation().latitude
            )
        ).zoom(17.0).build()
        navigationLocationProvider.changePosition(
            ApplicationStateData.getInstance().getCurrentLocation()
        )
        mapView.getMapboxMap().setCamera(cameraOptions)

    }

    fun stopNavigation() {

        unregisterObservers()
        clearRoutesAndArrow()

        if (::voiceInstructionsPlayer.isInitialized) {
            voiceInstructionsPlayer.clear()
            voiceInstructionsPlayer.shutdown()
        }
        if (::speechApi.isInitialized) {
            speechApi.cancel()
        }

        mapboxNavigation.stopTripSession()
        mapboxNavigation.resetTripSession()

        if (isNavigationInProgress)
            isNavigationInProgress = false


    }

    companion object {
        private val TAG = MapApplication::class.java.simpleName
    }


    private fun formatTime(seconds: Double): String {
        if (seconds < 60) {
            return String.format("%1$.0f sec", seconds)
        }
        if (seconds < (60 * 2)) // less than 2 minutes
        {
            return String.format("%1$.0f min<br>%2$.0f sec", seconds / 60, seconds % 60)
        }

        return if (seconds < (60 * 60)) // less than 1 hour
        {
            String.format("%1$.0f min", seconds / 60, seconds % 60)
        } else {
            String.format(
                "%1$.0f hr<br>%2$.0f min", seconds / (60 * 60), (seconds % (60 * 60)) / 60
            )
        }
    }


    private fun formatDistance(meters: Double): String {
        return if (meters < 1000) {
            String.format("%.0f m", meters);
        } else if (meters < 10000) {
            String.format("%.1f km", meters / 1000.0);
        } else {
            String.format("%.0f km", meters / 1000.0);
        }
    }

    override fun onNewLocation(location: Location?) {
        navigationLocationProvider.changePosition(
            location = location!!,
            keyPoints = emptyList(),
        )

        if (System.currentTimeMillis() - mapCameraRecenterTimer > MAPBOX_DELAY_TIMER) {
            mapCameraRecenterTimer = System.currentTimeMillis()
            //sanitizeNavigation()

            if (isFirstTime) {
                isFirstTime = false
                viewportDataSource.followingZoomPropertyOverride(17.0)
                viewportDataSource.followingPadding =
                    EdgeInsets(0.0, 0.0, ImageUtil.dpToPx(250).toDouble(), 0.0)
            }

        }
        navigationCamera.requestNavigationCameraToFollowing()

        if (location != null) {
            viewportDataSource.onLocationChanged(location)
        }
        viewportDataSource.evaluate()


    }

    fun setCurrentLocation(location: Location?) {
        location?.let {
            mapView.getMapboxMap().easeTo(
                CameraOptions.Builder()
                    .center(Point.fromLngLat(location.longitude, location.latitude))
                    .zoom(17.0)
                    .padding(EdgeInsets(500.0, 0.0, 0.0, 0.0))
                    .build()
            )


        }
    }


    fun registerCameraMoveLocationObserver(listener: OnCameraIdleListener) {
        onCameraIdleListener = listener
    }

    interface OnCameraIdleListener {
        fun onCameraIdle(location: Location?)
    }
}